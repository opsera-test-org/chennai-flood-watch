name: 2-CI Build Scan Push - chennai-flood-watch - dev

on:
  push:
    branches:
      - main
    paths-ignore:
      - '.github/workflows/1-bootstrap-*.yaml'
      - 'README.md'
      - 'docs/**'

env:
  APP_NAME: chennai-flood-watch
  TENANT: opsera
  ENVIRONMENT: dev
  AWS_REGION: us-west-2
  HUB_CLUSTER: argocd-usw2
  SPOKE_CLUSTER: opsera-usw2-np
  ECR_REPO_NAME: opsera/chennai-flood-watch
  NAMESPACE: opsera-chennai-flood-watch-dev
  ARGOCD_SERVER: argocd-usw2.agent.opsera.dev

jobs:
  # Stage 1: Security Scan (Gitleaks - Secrets Detection)
  security-scan:
    name: 1-Security Scan (Secrets)
    runs-on: ubuntu-latest
    continue-on-error: true
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Run Gitleaks
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Summary
        if: always()
        run: |
          echo "### ðŸ” Security Scan (Gitleaks)" >> $GITHUB_STEP_SUMMARY
          echo "- Status: Completed (warn-only mode)" >> $GITHUB_STEP_SUMMARY
          echo "- Mode: continue-on-error=true" >> $GITHUB_STEP_SUMMARY

  # Stage 2: Build Image
  build-image:
    name: 2-Build Docker Image
    runs-on: ubuntu-latest
    needs: security-scan
    if: always() && (needs.security-scan.result == 'success' || needs.security-scan.result == 'failure')
    outputs:
      image_tag: ${{ steps.meta.outputs.image_tag }}
      short_sha: ${{ steps.meta.outputs.short_sha }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Generate image metadata
        id: meta
        run: |
          SHORT_SHA=$(git rev-parse --short=7 HEAD)
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          IMAGE_TAG="${SHORT_SHA}-${TIMESTAMP}"
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "short_sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
          echo "IMAGE_TAG=${IMAGE_TAG}" >> $GITHUB_ENV
      
      - name: Build Docker image (local only)
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: false
          load: true
          tags: ${{ env.APP_NAME }}:${{ steps.meta.outputs.image_tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VCS_REF=${{ github.sha }}
      
      - name: Save image for scanning
        run: |
          docker save ${{ env.APP_NAME }}:${{ steps.meta.outputs.image_tag }} -o /tmp/image.tar
      
      - name: Upload image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: /tmp/image.tar
          retention-days: 1
      
      - name: Summary
        run: |
          echo "### ðŸ—ï¸ Build Docker Image" >> $GITHUB_STEP_SUMMARY
          echo "- Image: \`${{ env.APP_NAME }}:${{ steps.meta.outputs.image_tag }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Status: Built (not pushed yet)" >> $GITHUB_STEP_SUMMARY

  # Stage 3: Grype Scan (Container Vulnerability Scanning)
  grype-scan:
    name: 3-Grype Vulnerability Scan
    runs-on: ubuntu-latest
    needs: build-image
    continue-on-error: true
    
    steps:
      - name: Download image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp
      
      - name: Load Docker image
        run: |
          docker load -i /tmp/image.tar
      
      - name: Install Grype
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin
      
      - name: Run Grype scan
        run: |
          grype ${{ env.APP_NAME }}:${{ needs.build-image.outputs.image_tag }} \
            --fail-on high \
            --output table \
            --output json=grype-report.json \
            --output sarif=grype-report.sarif
        continue-on-error: true
      
      - name: Upload Grype results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: grype-report.sarif
          category: grype-container-scan
      
      - name: Upload Grype JSON report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: grype-report
          path: grype-report.json
          retention-days: 30
      
      - name: Summary
        if: always()
        run: |
          echo "### ðŸ” Grype Vulnerability Scan" >> $GITHUB_STEP_SUMMARY
          echo "- Image: \`${{ env.APP_NAME }}:${{ needs.build-image.outputs.image_tag }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Status: Completed (warn-only mode)" >> $GITHUB_STEP_SUMMARY
          echo "- Mode: continue-on-error=true" >> $GITHUB_STEP_SUMMARY

  # Stage 4: Push to ECR
  push-to-ecr:
    name: 4-Push to ECR
    runs-on: ubuntu-latest
    needs: [build-image, grype-scan]
    if: always() && needs.build-image.result == 'success'
    permissions:
      contents: read
      id-token: write
    outputs:
      ecr_image: ${{ steps.push.outputs.ecr_image }}
    
    steps:
      - name: Download image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp
      
      - name: Load Docker image
        run: |
          docker load -i /tmp/image.tar
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Push image to ECR
        id: push
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          ECR_IMAGE="${ECR_REGISTRY}/${{ env.ECR_REPO_NAME }}:${{ needs.build-image.outputs.image_tag }}"
          
          docker tag ${{ env.APP_NAME }}:${{ needs.build-image.outputs.image_tag }} ${ECR_IMAGE}
          docker push ${ECR_IMAGE}
          
          echo "ecr_image=${ECR_IMAGE}" >> $GITHUB_OUTPUT
          echo "ECR_IMAGE=${ECR_IMAGE}" >> $GITHUB_ENV
      
      - name: Summary
        run: |
          echo "### ðŸ“¦ Push to ECR" >> $GITHUB_STEP_SUMMARY
          echo "- Image: \`${{ steps.push.outputs.ecr_image }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Status: Pushed successfully" >> $GITHUB_STEP_SUMMARY

  # Stage 5: Refresh ECR Secret (on SPOKE cluster)
  refresh-ecr-secret:
    name: 5-Refresh ECR Secret
    runs-on: ubuntu-latest
    needs: push-to-ecr
    permissions:
      contents: read
      id-token: write
    
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Configure kubectl for spoke cluster
        run: |
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }} --alias spoke
          kubectl config use-context spoke
      
      - name: Create/Update ECR credentials secret
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          ECR_TOKEN=$(aws ecr get-login-password --region ${{ env.AWS_REGION }})
          
          kubectl delete secret ecr-credentials -n ${{ env.NAMESPACE }} --ignore-not-found=true
          kubectl create secret docker-registry ecr-credentials \
            -n ${{ env.NAMESPACE }} \
            --docker-server=${ECR_REGISTRY} \
            --docker-username=AWS \
            --docker-password=${ECR_TOKEN}
          
          echo "âœ“ ECR credentials secret refreshed in namespace: ${{ env.NAMESPACE }}"
      
      - name: Summary
        run: |
          echo "### ðŸ”‘ ECR Secret Refreshed" >> $GITHUB_STEP_SUMMARY
          echo "- Namespace: \`${{ env.NAMESPACE }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Secret: \`ecr-credentials\`" >> $GITHUB_STEP_SUMMARY

  # Stage 6: Update Manifests
  update-manifests:
    name: 6-Update Manifests
    runs-on: ubuntu-latest
    needs: [push-to-ecr, refresh-ecr-secret]
    permissions:
      contents: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}
          fetch-depth: 0
      
      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
      
      - name: Update kustomization image tag
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          ECR_REPO="${ECR_REGISTRY}/${{ env.ECR_REPO_NAME }}"
          IMAGE_TAG="${{ needs.build-image.outputs.image_tag }}"
          
          KUSTOMIZATION=".opsera-${APP_NAME}/k8s/overlays/${{ env.ENVIRONMENT }}/kustomization.yaml"
          
          # Update newName and newTag
          sed -i "s|newName:.*|newName: ${ECR_REPO}|g" ${KUSTOMIZATION}
          sed -i "s|newTag:.*|newTag: ${IMAGE_TAG}|g" ${KUSTOMIZATION}
          
          echo "âœ“ Updated ${KUSTOMIZATION} with image ${ECR_REPO}:${IMAGE_TAG}"
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ env.AWS_REGION }}
      
      - name: Commit and push changes
        run: |
          git pull --rebase origin main || true
          
          if git diff --quiet; then
            echo "No changes to commit"
            exit 0
          fi
          
          git add .opsera-${APP_NAME}/k8s/overlays/${{ env.ENVIRONMENT }}/kustomization.yaml
          git commit -m "[skip ci] Update ${{ env.ENVIRONMENT }} image to ${{ needs.build-image.outputs.image_tag }}"
          
          MAX_RETRIES=3
          RETRY=0
          while [ $RETRY -lt $MAX_RETRIES ]; do
            if git push origin main; then
              echo "âœ“ Pushed changes successfully"
              break
            else
              RETRY=$((RETRY + 1))
              echo "Push failed, attempt $RETRY of $MAX_RETRIES"
              if [ $RETRY -lt $MAX_RETRIES ]; then
                git pull --rebase origin main
                sleep 2
              else
                echo "âŒ Failed to push after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done
      
      - name: Summary
        run: |
          echo "### ðŸ“ Manifests Updated" >> $GITHUB_STEP_SUMMARY
          echo "- Environment: \`${{ env.ENVIRONMENT }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Image Tag: \`${{ needs.build-image.outputs.image_tag }}\`" >> $GITHUB_STEP_SUMMARY

  # Stage 7: Create/Update ArgoCD Application (MANDATORY - RULE 213)
  create-argocd-app:
    name: 7-Create ArgoCD Application
    runs-on: ubuntu-latest
    needs: update-manifests
    permissions:
      contents: read
      id-token: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Configure kubectl for hub cluster
        run: |
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }} --alias hub
          kubectl config use-context hub
      
      - name: Create/Update ArgoCD Application
        run: |
          kubectl apply -f .opsera-${APP_NAME}/argocd/${APP_NAME}-${{ env.ENVIRONMENT }}-application.yaml
          echo "âœ“ ArgoCD application created/updated: ${APP_NAME}-${{ env.ENVIRONMENT }}"
      
      - name: Summary
        run: |
          echo "### ðŸŽ¯ ArgoCD Application" >> $GITHUB_STEP_SUMMARY
          echo "- Application: \`${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Status: Created/Updated" >> $GITHUB_STEP_SUMMARY

  # Stage 8: ArgoCD Hard Refresh
  argocd-refresh:
    name: 8-ArgoCD Hard Refresh
    runs-on: ubuntu-latest
    needs: create-argocd-app
    permissions:
      contents: read
      id-token: write
    
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Configure kubectl for hub cluster
        run: |
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }} --alias hub
          kubectl config use-context hub
      
      - name: Trigger ArgoCD hard refresh
        run: |
          kubectl patch application ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} \
            -n argocd \
            --type merge \
            -p '{"operation":{"initiatedBy":{"username":"github-actions"},"sync":{"revision":"HEAD"}}}'
          
          echo "âœ“ ArgoCD hard refresh triggered"
          sleep 5
      
      - name: Summary
        run: |
          echo "### ðŸ”„ ArgoCD Refresh" >> $GITHUB_STEP_SUMMARY
          echo "- Application: \`${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Status: Refreshed" >> $GITHUB_STEP_SUMMARY

  # Stage 9: Sync ArgoCD
  argocd-sync:
    name: 9-ArgoCD Sync
    runs-on: ubuntu-latest
    needs: argocd-refresh
    permissions:
      contents: read
      id-token: write
    
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Configure kubectl for hub cluster
        run: |
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }} --alias hub
          kubectl config use-context hub
      
      - name: Trigger ArgoCD sync
        run: |
          kubectl patch application ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} \
            -n argocd \
            --type merge \
            -p '{"operation":{"initiatedBy":{"username":"github-actions"},"sync":{"syncStrategy":{"hook":{},"apply":{"force":false}}}}}'
          
          echo "âœ“ ArgoCD sync triggered"
      
      - name: Wait for sync completion
        run: |
          echo "Waiting for ArgoCD sync to complete..."
          for i in {1..60}; do
            SYNC_STATUS=$(kubectl get application ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} -n argocd -o jsonpath='{.status.sync.status}')
            HEALTH_STATUS=$(kubectl get application ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} -n argocd -o jsonpath='{.status.health.status}')
            
            echo "Sync Status: ${SYNC_STATUS}, Health Status: ${HEALTH_STATUS}"
            
            if [ "${SYNC_STATUS}" = "Synced" ] && [ "${HEALTH_STATUS}" = "Healthy" ]; then
              echo "âœ“ Application synced and healthy"
              exit 0
            fi
            
            sleep 10
          done
          
          echo "âš ï¸ Sync timeout - check ArgoCD UI"
          exit 1
      
      - name: Summary
        if: always()
        run: |
          echo "### âœ… ArgoCD Sync" >> $GITHUB_STEP_SUMMARY
          echo "- Application: \`${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Status: Synced" >> $GITHUB_STEP_SUMMARY

  # Stage 10: Verify Deployment
  verify-deployment:
    name: 10-Verify Deployment
    runs-on: ubuntu-latest
    needs: argocd-sync
    permissions:
      contents: read
      id-token: write
    
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Configure kubectl for spoke cluster
        run: |
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }} --alias spoke
          kubectl config use-context spoke
      
      - name: Verify pods are running
        run: |
          echo "Checking pods in namespace: ${{ env.NAMESPACE }}"
          kubectl get pods -n ${{ env.NAMESPACE }} -l app=${{ env.APP_NAME }}
          
          # Wait for pods to be ready
          kubectl wait --for=condition=ready pod -l app=${{ env.APP_NAME }} -n ${{ env.NAMESPACE }} --timeout=300s
          
          echo "âœ“ All pods are running and ready"
      
      - name: Verify deployment
        run: |
          READY_REPLICAS=$(kubectl get deployment ${{ env.APP_NAME }} -n ${{ env.NAMESPACE }} -o jsonpath='{.status.readyReplicas}')
          DESIRED_REPLICAS=$(kubectl get deployment ${{ env.APP_NAME }} -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.replicas}')
          
          echo "Ready Replicas: ${READY_REPLICAS}/${DESIRED_REPLICAS}"
          
          if [ "${READY_REPLICAS}" = "${DESIRED_REPLICAS}" ]; then
            echo "âœ“ Deployment is healthy"
          else
            echo "âŒ Deployment is not healthy"
            exit 1
          fi
      
      - name: Test application endpoint
        run: |
          echo "Testing application endpoint..."
          ENDPOINT="https://${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}.agent.opsera.dev"
          
          for i in {1..30}; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" ${ENDPOINT} || echo "000")
            echo "Attempt $i: HTTP ${HTTP_CODE}"
            
            if [ "${HTTP_CODE}" = "200" ] || [ "${HTTP_CODE}" = "301" ] || [ "${HTTP_CODE}" = "302" ]; then
              echo "âœ“ Application is accessible at ${ENDPOINT}"
              exit 0
            fi
            
            sleep 10
          done
          
          echo "âš ï¸ Application endpoint not accessible yet - may need more time"
      
      - name: Summary
        if: always()
        run: |
          echo "### âœ… Deployment Verified" >> $GITHUB_STEP_SUMMARY
          echo "- Namespace: \`${{ env.NAMESPACE }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- URL: \`https://${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}.agent.opsera.dev\`" >> $GITHUB_STEP_SUMMARY

  # Stage 11: Deployment Landscape
  deployment-landscape:
    name: 11-Deployment Landscape
    runs-on: ubuntu-latest
    needs: verify-deployment
    if: always()
    permissions:
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Generate deployment summary
        run: |
          cat > deployment-summary.md <<EOF
          # ðŸš€ Deployment Summary
          
          ## Application Information
          - **Application**: ${{ env.APP_NAME }}
          - **Environment**: ${{ env.ENVIRONMENT }}
          - **Namespace**: ${{ env.NAMESPACE }}
          - **Image Tag**: ${{ needs.build-image.outputs.image_tag }}
          - **Short SHA**: ${{ needs.build-image.outputs.short_sha }}
          
          ## Infrastructure
          - **Hub Cluster**: ${{ env.HUB_CLUSTER }}
          - **Spoke Cluster**: ${{ env.SPOKE_CLUSTER }}
          - **Region**: ${{ env.AWS_REGION }}
          - **ECR Repository**: ${{ env.ECR_REPO_NAME }}
          
          ## Access
          - **Application URL**: https://${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}.agent.opsera.dev
          - **ArgoCD Server**: https://${{ env.ARGOCD_SERVER }}
          
          ## Pipeline Stages
          1. âœ… Security Scan (Gitleaks)
          2. âœ… Build Docker Image
          3. âœ… Grype Vulnerability Scan
          4. âœ… Push to ECR
          5. âœ… Refresh ECR Secret
          6. âœ… Update Manifests
          7. âœ… Create ArgoCD Application
          8. âœ… ArgoCD Hard Refresh
          9. âœ… ArgoCD Sync
          10. âœ… Verify Deployment
          11. âœ… Deployment Landscape
          
          ## Deployment Time
          - **Started**: ${{ github.event.head_commit.timestamp }}
          - **Completed**: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
          
          ---
          
          *Powered by Opsera Code-to-Cloud Enterprise v0.932*
          EOF
          
          cat deployment-summary.md >> $GITHUB_STEP_SUMMARY
      
      - name: Upload deployment summary
        uses: actions/upload-artifact@v4
        with:
          name: deployment-summary
          path: deployment-summary.md
          retention-days: 30
