name: Setup HTTPS with cert-manager

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      domain:
        description: 'Custom domain (optional, uses default if empty)'
        required: false
        default: ''

env:
  APP_NAME: chflood
  TENANT: opsera
  REGION: us-west-2
  BASE_DOMAIN: agents.opsera.dev

jobs:
  setup-https:
    name: Setup HTTPS Certificate
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Determine Domain
        id: domain
        run: |
          ENV="${{ github.event.inputs.environment }}"
          CUSTOM_DOMAIN="${{ github.event.inputs.domain }}"

          if [ -n "$CUSTOM_DOMAIN" ]; then
            DOMAIN="$CUSTOM_DOMAIN"
          else
            DOMAIN="${{ env.TENANT }}-${{ env.APP_NAME }}-${ENV}.${{ env.BASE_DOMAIN }}"
          fi

          echo "domain=${DOMAIN}" >> $GITHUB_OUTPUT
          echo "ðŸ“ Domain: ${DOMAIN}" >> $GITHUB_STEP_SUMMARY

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GithubActionsRole
          aws-region: ${{ env.REGION }}
          role-session-name: https-setup-${{ env.APP_NAME }}

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --name ${{ env.TENANT }}-usw2-np --region ${{ env.REGION }}

      - name: Install cert-manager (if not exists)
        run: |
          if kubectl get namespace cert-manager 2>/dev/null; then
            echo "âœ… cert-manager already installed" >> $GITHUB_STEP_SUMMARY
          else
            echo "ðŸ“¦ Installing cert-manager..." >> $GITHUB_STEP_SUMMARY
            kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.3/cert-manager.yaml

            echo "â³ Waiting for cert-manager to be ready..."
            kubectl wait --for=condition=Available --timeout=300s \
              deployment/cert-manager -n cert-manager
            kubectl wait --for=condition=Available --timeout=300s \
              deployment/cert-manager-webhook -n cert-manager
            kubectl wait --for=condition=Available --timeout=300s \
              deployment/cert-manager-cainjector -n cert-manager

            echo "âœ… cert-manager installed successfully" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Create ClusterIssuer for Let's Encrypt
        run: |
          cat <<EOF | kubectl apply -f -
          apiVersion: cert-manager.io/v1
          kind: ClusterIssuer
          metadata:
            name: letsencrypt-prod
          spec:
            acme:
              server: https://acme-v02.api.letsencrypt.org/directory
              email: devops@opsera.io
              privateKeySecretRef:
                name: letsencrypt-prod
              solvers:
              - http01:
                  ingress:
                    class: nginx
          EOF

          echo "âœ… ClusterIssuer created" >> $GITHUB_STEP_SUMMARY

      - name: Update Ingress with TLS
        run: |
          ENV="${{ github.event.inputs.environment }}"
          DOMAIN="${{ steps.domain.outputs.domain }}"
          NAMESPACE="${{ env.TENANT }}-${{ env.APP_NAME }}-${ENV}"

          cat <<EOF | kubectl apply -f -
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: ${{ env.APP_NAME }}-ingress
            namespace: ${NAMESPACE}
            annotations:
              cert-manager.io/cluster-issuer: "letsencrypt-prod"
              nginx.ingress.kubernetes.io/ssl-redirect: "true"
              nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
          spec:
            ingressClassName: nginx
            tls:
            - hosts:
              - ${DOMAIN}
              secretName: ${{ env.APP_NAME }}-tls
            rules:
            - host: ${DOMAIN}
              http:
                paths:
                - path: /
                  pathType: Prefix
                  backend:
                    service:
                      name: ${{ env.APP_NAME }}-service
                      port:
                        number: ${{ env.PORT }}
          EOF

          echo "âœ… Ingress updated with TLS configuration" >> $GITHUB_STEP_SUMMARY

      - name: Wait for Certificate
        run: |
          ENV="${{ github.event.inputs.environment }}"
          NAMESPACE="${{ env.TENANT }}-${{ env.APP_NAME }}-${ENV}"

          echo "â³ Waiting for certificate to be issued..."

          for i in {1..60}; do
            STATUS=$(kubectl get certificate ${{ env.APP_NAME }}-tls -n ${NAMESPACE} -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}' 2>/dev/null || echo "NotFound")

            if [ "$STATUS" = "True" ]; then
              echo "âœ… Certificate issued successfully!" >> $GITHUB_STEP_SUMMARY
              break
            fi

            echo "Waiting for certificate... ($i/60)"
            sleep 5
          done

          if [ "$STATUS" != "True" ]; then
            echo "âš ï¸ Certificate not ready after 5 minutes. Check cert-manager logs." >> $GITHUB_STEP_SUMMARY
            kubectl describe certificate ${{ env.APP_NAME }}-tls -n ${NAMESPACE}
          fi

      - name: Verify HTTPS Access
        run: |
          DOMAIN="${{ steps.domain.outputs.domain }}"

          echo "ðŸ” Verifying HTTPS access..."
          sleep 10

          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" https://${DOMAIN} || echo "000")

          if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "301" ] || [ "$HTTP_CODE" = "302" ]; then
            echo "âœ… HTTPS is working! (HTTP $HTTP_CODE)" >> $GITHUB_STEP_SUMMARY
          else
            echo "âš ï¸ HTTPS verification returned HTTP $HTTP_CODE" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Setup Summary
        run: |
          ENV="${{ github.event.inputs.environment }}"
          DOMAIN="${{ steps.domain.outputs.domain }}"

          echo "## ðŸ”’ HTTPS Setup Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** ${ENV}" >> $GITHUB_STEP_SUMMARY
          echo "- **Domain:** ${DOMAIN}" >> $GITHUB_STEP_SUMMARY
          echo "- **Certificate Issuer:** Let's Encrypt Production" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Access Your Application" >> $GITHUB_STEP_SUMMARY
          echo "ðŸŒ **URL:** https://${DOMAIN}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Verify Certificate" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
          echo "kubectl get certificate -n ${{ env.TENANT }}-${{ env.APP_NAME }}-${ENV}" >> $GITHUB_STEP_SUMMARY
          echo "kubectl describe certificate ${{ env.APP_NAME }}-tls -n ${{ env.TENANT }}-${{ env.APP_NAME }}-${ENV}" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### DNS Configuration" >> $GITHUB_STEP_SUMMARY
          echo "Ensure your DNS record points to the NGINX Ingress Controller's LoadBalancer:" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
          echo "kubectl get svc -n ingress-nginx" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
