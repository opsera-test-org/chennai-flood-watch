name: Reusable Deploy - ch-flood

on:
  workflow_call:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: string
      image_tag:
        description: 'Docker image tag to deploy'
        required: true
        type: string
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - dev
          - qa
          - staging
      image_tag:
        description: 'Docker image tag to deploy'
        required: true
        type: string

permissions:
  contents: read
  id-token: write

env:
  APP_NAME: ch-flood
  TENANT: opsera
  REGION: us-west-2
  HUB_CLUSTER: argocd-usw2
  SPOKE_CLUSTER: opsera-usw2-np

jobs:
  deploy:
    name: Deploy to ${{ inputs.environment }}
    runs-on: ubuntu-latest
    environment:
      name: ${{ inputs.environment }}
      url: https://${{ env.TENANT }}-${{ env.APP_NAME }}-${{ inputs.environment }}.agent.opsera.dev
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.REGION }}

      - name: Update kubeconfig for Hub Cluster
        run: |
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.REGION }}

      - name: Update kubeconfig for Spoke Cluster
        run: |
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.REGION }}

      - name: Sync ArgoCD Application
        run: |
          APP_NAME="${{ env.TENANT }}-${{ env.APP_NAME }}-${{ inputs.environment }}"
          NAMESPACE="${{ env.TENANT }}-${{ env.APP_NAME }}-${{ inputs.environment }}"

          # Switch to hub cluster context
          kubectl config use-context arn:aws:eks:${{ env.REGION }}:$(aws sts get-caller-identity --query Account --output text):cluster/${{ env.HUB_CLUSTER }}

          # Trigger sync
          kubectl patch application $APP_NAME -n argocd \
            --type merge \
            -p '{"operation":{"initiatedBy":{"username":"github-actions"},"sync":{"revision":"main"}}}'

          echo "âœ… Triggered ArgoCD sync" >> $GITHUB_STEP_SUMMARY

      - name: Wait for Rollout
        run: |
          NAMESPACE="${{ env.TENANT }}-${{ env.APP_NAME }}-${{ inputs.environment }}"

          # Switch to spoke cluster context
          kubectl config use-context arn:aws:eks:${{ env.REGION }}:$(aws sts get-caller-identity --query Account --output text):cluster/${{ env.SPOKE_CLUSTER }}

          # Wait for deployment rollout with degraded grace period (RULE 171)
          DEGRADED_COUNT=0
          for i in {1..60}; do
            if kubectl get deployment ${{ env.APP_NAME }} -n $NAMESPACE &>/dev/null; then
              STATUS=$(kubectl rollout status deployment/${{ env.APP_NAME }} -n $NAMESPACE --timeout=10s 2>&1 || echo "waiting")

              if echo "$STATUS" | grep -q "successfully rolled out"; then
                echo "âœ… Deployment rolled out successfully" >> $GITHUB_STEP_SUMMARY
                break
              elif echo "$STATUS" | grep -qi "degraded"; then
                DEGRADED_COUNT=$((DEGRADED_COUNT + 1))
                echo "âš ï¸ Degraded state detected ($DEGRADED_COUNT/6)"
                if [ $DEGRADED_COUNT -ge 6 ]; then
                  echo "âŒ Deployment degraded for too long" >> $GITHUB_STEP_SUMMARY
                  kubectl describe deployment ${{ env.APP_NAME }} -n $NAMESPACE | tee -a $GITHUB_STEP_SUMMARY
                  exit 1
                fi
              else
                DEGRADED_COUNT=0
              fi
            fi
            sleep 5
          done

      - name: Verify Pods
        run: |
          NAMESPACE="${{ env.TENANT }}-${{ env.APP_NAME }}-${{ inputs.environment }}"

          kubectl get pods -n $NAMESPACE -l app=${{ env.APP_NAME }} | tee -a $GITHUB_STEP_SUMMARY

          kubectl wait --for=condition=ready pod \
            -l app=${{ env.APP_NAME }} \
            -n $NAMESPACE \
            --timeout=300s

          echo "âœ… All pods are ready" >> $GITHUB_STEP_SUMMARY

      - name: Health Check
        run: |
          NAMESPACE="${{ env.TENANT }}-${{ env.APP_NAME }}-${{ inputs.environment }}"
          POD=$(kubectl get pod -n $NAMESPACE -l app=${{ env.APP_NAME }} -o jsonpath='{.items[0].metadata.name}')

          echo "Testing pod: $POD"
          kubectl port-forward -n $NAMESPACE $POD 8081:8080 &
          PF_PID=$!
          sleep 3

          if wget -qO- --timeout=10 http://localhost:8081/ > /dev/null 2>&1; then
            echo "âœ… Health check passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "âš ï¸ Health check warning" >> $GITHUB_STEP_SUMMARY
          fi

          kill $PF_PID || true

      - name: Deployment Summary
        if: always()
        run: |
          echo "## ðŸš€ Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** ${{ inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Tag:** \`${{ inputs.image_tag }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **URL:** https://${{ env.TENANT }}-${{ env.APP_NAME }}-${{ inputs.environment }}.agent.opsera.dev" >> $GITHUB_STEP_SUMMARY
